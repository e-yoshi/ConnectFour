# ECE350 Connect Four
# Written in Duke ECE350 Assembly


# Register Convention
# $r1, $r3 are return registers
# $r2 is our temporary register that stores 2000+inputVar for load from Table Map II (which player where)
# $r4 is our temporary register that stores 4000+inputVar for load from Table Map
# $r6, $r7 are argument registers
#t $r8 is a temporary register
# $r9 is current player. 0 is player 0, 1 is player 1
# $r10 will be input
# $r11 will be numberRows
#t r13 is a temporary register 
# $r12, $r14 are temporary registers that hold 2000, 4000 + input offset for load store RESULTS into Table Maps
# $r15 is Win? If 1, game over. if 0, keep playing
# $r16 is always the value 1. comes in handy.

#IMPLEMENT:
	# testOccupied Function
	# readInput Function
	# placeBlock
	# endGame
	# initGame
	# checkWin
	# changePlayer
# ALSO IMPLEMENT
	# We have numberRows. We can add boundary checking if we feel that we want our design to be robust.
	# personally I think that this is a later step. First get it working. Maybe robustness is not an issue.
	# we can assume we have smart players that don't try and break our board.


# Table Mapping
# Table Map at 4000 is our map for presence
# Table Map II at 2000 is our map for which player, once we check the map at 4K


# All 
initGame:
addi $r2, $r0, 2000
addi $r4, $r0, 4000
addi $r9, $r0, 1 #currPlayer is 0
add $r10, $r0, $r0 #initialize inputVar to 0
add $r11, $r0, $r0 #numberRows init as 0
add $r15, $r0, $r0 #init gameOver to 0. 1 is game over



gameLoop:
	jal readInput # now input var should be in register 10	
placeLoop: # loop for placing a block
	jal testOccupied #test if current block is occupied, if occupied, return 1. if no, return 0
	blt $r0, $r1, skipIncrement # if NOT occupied / $r1 is 0, skip adding to input var
		addi $r10, $r10, 7 # increment input
		addi $r11, $r11, 1 # increment numberRows
		j placeLoop		   # loop back, check if next block above this one is free
	skipIncrement:
		jal placeBlock
		# checkWin(User) -- pass in User as arg, returns 1 if user has won.
			# after winning, maybe all blocks blink or something. 
		# set pass-in vars to checkWin
			# $r9 --> currPlayer
		jal checkWin
		# if won, $r15 will be 1. if game NOT over, $r15 is 0
		bne $r0, $r15, endGame	# if not 0, branch to endGame. $r15 is 1, so game is over!
		#game NOT over. Change currPlayer
		jal changePlayer
		# keep playing the game
		j gameLoop

# Read Input from the current player, set to 1 through 7
readInput:
	



	

# test if current block is occupied. return 1 in $r1 if occupied, 0 if not
testOccupied: 
	# intuition: load from specified address in TABLE MAP. if 1, block is present.
	addi $r4, $r10, 4000
	load $r14, 0($r4)		# either a 0 or 1
	add $r1, $r0, $r14		# put result into return register. would have directly loaded, but other areas of code need r1 already

# place a block at given input, used in $r10. RESET input after placeBlock is called
placeBlock:
#WRITE TO A DUPLICATE TABLE MAP
	




# check if game over
checkWin:
	




#change CurrPlayer
changePlayer:
	#if (Current Player == A) 
		#change Current Player to B
	#if (Current Player == B) 
		#change Current Player to A
	
	# test if currPlayer is NOT 0, i.e., player is 1. change player to 0.
	bne $r0, $r9, changePlayerSubLabel
	# did NOT branch here. that means current player is 0. change player to 1 and exit 
	addi $r9, $r0, 1
	jr $r31 #jr return register
	changePlayerSubLabel: 	#we just branched here because player is 1. change player to 0,return
	addi $r9, $r0, 0
	jr $r31 #jr return register

# game is over! 
endGame: 
	



















